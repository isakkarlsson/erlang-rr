%%% @author Isak Karlsson <isak-kar@dsv.su.se>
%%% @copyright (C) 2013, 
%%% @doc
%%%
%%% Module for handling the examples
%%%
%%% @end
%%% Created :  4 Feb 2013 by Isak Karlsson <isak-kar@dsv.su.se>
-module(rr_example).
-compile(export_all).
-export([init/0,
	 load/2]).


%%
%% Init an ets table that stores all examples in memory. The examples
%% are described with their features as a tuple. That is, {Id,
%% {x1,...,xn}}.
%%
init() ->
    ets:new(examples, [named_table, {read_concurrency, true}]).

load(File, Cores) ->
    Types = case csv:next_line(File) of
		{ok, Types0, _} ->
		    parse_type_declaration(Types0);
		eof ->
		    throw({error, features_type_error})
	    end,
    Features = case csv:next_line(File) of
		    {ok, Features0, _} ->
		       parse_feature_declaration(Features0, Types);			 
		    eof ->
			throw({error, features_type_error})
		end,
    {Features, parse_examples(File, Cores, ClassId, Features)}.
    
    
%%
%% Parses a type declaration: ["class", "categoric"+, "numeric"+] in
%% any order. Returns {ClassId, [features...]}
%%
parse_type_declaration(Types) ->
    parse_type_declaration(Types, missing, 1, []).

parse_type_declaration([], ClassId, _, Acc) ->
    {ClassId, lists:reverse(Acc)};
parse_type_declaration([Type0|Rest], ClassId, Id, Acc) ->
    Type = list_to_atom(Type0),
    case Type of
	Type when Type =:= numeric;
		  Type =:= categoric ->
	    parse_type_declaration(Rest, ClassId, Id + 1, [Type|Acc]);
	Type when Type =:= class;
		  ClassId =:= missing ->
	    parse_type_declaration(Rest, Id, Id + 1, Acc);
	_ ->
	    throw({error, {invalid_type_declaration, Id}})
    end.

%%
%% Parse feature declaration
%%
parse_feature_declaration(Features0, {ClassId, Types}) ->
    {_, Features} = take_class(Features0, ClassId),
    if length(Features) =/= length(Types) ->
	    throw({error, {invalid_feature_declaration, length(Features)}});
       true ->
	    parse_feature_declaration(Features, Types, [])
    end.

parse_feature_declaration([], [], Acc) ->
    list_to_tuple(lists:reverse(Acc));
parse_feature_declaration([Feature|Features], [Type|Types], Acc) ->
    parse_feature_declaration(Features, Types, [{Type, list_to_atom(Feature)}|Acc]).

%%
%% Take class at id=N and return the the tuple {Class, RestOfList}
%%
take_class([A|R], 1) ->
    {A, R};
take_class(List, N) ->
    {L1, [Item|L2]} = lists:split(N-1, List),
    {Item, L1 ++ L2}.

